<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
 	
  <meta http-equiv="CONTENT-TYPE"
 content="text/html; charset=iso-8859-1">
  <title></title>
 	 	
  <meta name="GENERATOR" content="OpenOffice.org 1.0.1  (Solaris Sparc)">
 	
  <meta name="AUTHOR" content="Alexey Parshin">
 	
  <meta name="CREATED" content="20030208;9244200">
 	
  <meta name="CHANGEDBY" content="Alexey Parshin">
 	
  <meta name="CHANGED" content="20030209;8371700">
 	
  <style>
	<!--
		@page { size: 21.59cm 27.94cm; margin-left: 3.18cm; margin-right: 3.18cm; margin-top: 2.54cm; margin-bottom: 2.54cm }
		TD P { margin-bottom: 0.21cm }
		P { margin-bottom: 0.21cm }
		H2 { margin-bottom: 0.21cm }
		H2.western { font-family: "Albany", sans-serif; font-size: 14pt; font-style: italic }
		H2.cjk { font-size: 14pt; font-style: italic }
		H2.ctl { font-size: 14pt; font-style: italic }
	-->
	</style>
</head>
  <body lang="en-US">
 
<h1>Data Sources</h1>
 
<p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">by Alexey Parshin</font></font></p>
 
<p align="left" style="margin-bottom: 0cm;"><br>
 </p>
 
<p align="left" style="margin-bottom: 0cm;"><br>
 </p>
 
<p align="left" style="margin-bottom: 0cm;"><br>
 </p>
 
<p align="center" style="margin-bottom: 0cm;"><br>
 </p>
 
<ol>
 	<li>
    <p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">What 	is the Data Source and why do we need it?</font></font></p>
 	</li>
  <li>
    <p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">How 	can a Data Source be used?</font></font></p>
 	</li>
  <li>
    <p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">Minimal 	structure of a simple Data Source.</font></font></p>
 	</li>
  <li>
    <p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">Using 	a Data Source in widgets.</font></font></p>
 	</li>
  <li>
    <p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">Using 	Fl_Query as a Datasource.</font></font></p>
 	</li>
  <li>
    <p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">Datasource 	design example &#8211; Fl_Directory_DS.</font></font></p>
 	</li>
  <li>
    <p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">Database 	driver example &#8211; Fl_Some_Database.</font></font></p>
 </li>
</ol>
 
<p align="left" style="margin-bottom: 0cm;"><br>
 </p>
 
<p align="left" style="margin-bottom: 0cm;"><br>
 </p>
 
<h2 class="western"><br>
<br>
 </h2>
 
<h2 class="western"><br>
<br>
 </h2>
 
<h2 class="western">1. What is the Data Source and why do we need it?</h2>
 
<p align="left" style="margin-bottom: 0cm;"><font face="Clean"><font
 size="3">Different sources of the information require very different ways
to retrieve that information. The Datasource allows to hide the nature of 
information source behind the standard API, presenting information as rows
(if applicable) and columns of data. It is very typical that all the rows
have the same number of column types, and every column keeps it's data type
from row to row. Datasource provides the abilities to open the information
source and navigate through it. As soon it's opened, it has the list of the
columns, or fields. Every field has the data type, width (size) and alignment,
and, of course, you can read from it the actual data. As result, we have
an abstraction class and can use it without knowing anything about the actual
data. From the point of the particular widget, it's just a set of rows of 
fields. Widget opens the Datasource, reads the data, closes it. It doesn't
matter if that Datasource was actually a database Query, or an FTP files
directory. The widget has all the necessary information. </font></font> </p>
 
<h2 class="western">2. How can a Data Source be used?</h2>
 
<table width="100%" border="0" cellpadding="4" cellspacing="0">
 	<col width="104*"> 	<col width="152*"> 	<tbody>
    <tr valign="top">
 		<td width="41%"> 			
      <p><img src="DataSource_1.png" name="Graphic1" align="left"
 width="399" height="316" border="0">
      <br clear="left">
      <br>
 			</p>
 		</td>
 		<td width="59%"> 			
      <p><font face="Clean">There are a lot of different usages of the 			Datasource
in widgets. Some widgets, like List View, can utilize 			the whole Datasource
(DS) simultaneously, by reading and 			displaying it completely. Some widgets,
like Dialog, can use just 			one row of the DS in a time. And, finally, a
lot of widgets can 			use just one field of the row in DS. I'm not even going
to 			consider a pity group of remaining widgets that can't use DS at 			all.
In eFLTK, every widget has a field_name() method that allows 			to connect
any widget with the field of DS. Where is the DS 			connection in that schema?
Well, widgets are not used by 			themselves. Usually, widgets are placed
in the group, so the group 			should provide the DS, if widgets inside need
it. So, Fl_Group 			defines data_source() method to connect the group with
the DS, and 			couple of methods to load and unload data to/from widgets.
By the 			way, it means that we may write to some Datasources.</font></p>
 			
      <p><font face="Clean">Fl_Data_Source is the abstraction layer that 			hides
the essentials of every possible information source from the 			widgets.
It gives us the nice possibility to develop now the 			programs which will
use the Datasources that doesn't exist yet.</font></p>
 		</td>
 	</tr>
 
  </tbody>
</table>
 
<p><font face="Clean">So, how do we read data from Datasource, and how do
we write data to it? Very simple. First, we open the DS:</font></p>
 
<blockquote>
  <p><font face="Arial, sans-serif"><i>my_ds.open();</i></font></p>
</blockquote>
 
<p><font face="Clean">Datasource uses Fl_Variant to store every field. To
communicate with DS we first find the field by the field name or index (in
the DS row):</font></p>
 
<blockquote>
  <p><font face="Arial, sans-serif"><i>Fl_Data_Field&amp; first_name_field
= my_ds[&#8220;name&#8221;];</i></font></p>
  <p><font face="Arial, sans-serif"><i>Fl_Data_Field&amp; last_name_field
= my_ds[1];</i></font></p>
</blockquote>
  
<p><font face="Clean">Then we can just read the value from field, or write
it to the field:</font></p>
 
<blockquote>
  <p><font face="Arial, sans-serif"><i>Fl_String first_name = first_name_field;</i></font></p>
  <p><font face="Arial, sans-serif"><i>Fl_String last_name = &#8220;New last name&#8221;;</i></font></p>
  <p><font face="Arial, sans-serif"><i>last_name_field = last_name;</i></font></p>
</blockquote>
   
<p><font face="Clean">And , finally, we close DS:</font></p>
 
<blockquote>
  <p><font face="Arial, sans-serif"><i>my_ds.close();</i></font></p>
</blockquote>
 
<p><font face="Clean">Well, this is true for the abstract DS. The real Datasources
require to define some extra parameters prior to open(), like what are we
trying to open? In case of the database query it would be the text of SQL
statement, for Fl_Directory_DS it would be the path to the directory, etc..</font></p>
 
<h2 class="western">3. Minimal structure of a simple Data Source.</h2>
 
<p style="text-decoration: none;"><font face="Clean">The Fl_Data_Source is
an abstract class. It means you can't create an object that class - you should
derive your Data Source (DS) from Fl_Data_Source. Fl_Data_Source has several
groups of methods the actual DS should implement:</font></p>
 
<ul>
 	<li>
    <p style="margin-bottom: 0cm;"><font face="Clean">open() and 	close()
methods initiate and terminate the data access session</font></p>
 	</li>
  <li>
    <p style="margin-bottom: 0cm;"><font face="Clean">navigation 	methods
(first(), next(), etc.. ) allow to move between records in 	opened data source
    </font> 	</p>
 	</li>
  <li>
    <p><font face="Clean">field access methods allow access fields 	and fields'
data </font> 	</p>
 </li>
</ul>
 
<p><font face="Clean">To say it simple, all the abstract methods in Fl_Data_Source
should be implemented. The actual implementation may vary. Lets try to take
Fl_Directory_DS as an example.</font></p>
 
<blockquote><font face="Clean"><b>Open and close operations.</b><br>
First, Fl_Directory_DS reads the directory contents into an array of rows
of Fl_Data_Fields. Every Fl_Data_Fields object has a list of Fl_Data_Fields
for file name, file size, modification date, etc.. This covers the open()
method. The close() method simply releases everything allocated during open().
For the details please check the <i>src/widgets/Fl_Directory_DS.cpp</i>.<br>
  <br>
  <b>Navigation methods.</b><br>
For Fl_Directory_DS the navigation is very simple. The class member variable
m_current keeps the tracking of current data row in the opened DS. It doesn't
make any sense for closed DS, of course. So, methods like first()..last()
simply change the m_current row accordingly.<br>
  <br>
  <b>Field access.</b><br>
Datasource should support the field information and provide field data when 
necessary. As soon as DS is opened, the first data row becomes available.
At that moment, DS' current data row already should have the Fl_Data_Fields
initialized. Using Fl_Data_Fields fields, we can always extract the number
of available fields and information about data type of every field. Of course,
we still have to provide all this functionality through the Datasource methods,
but we already have all the necessary information.</font></blockquote>
 
<p align="left" style="margin-bottom: 0cm;"><font face="Clean">Every real
Datasource also would, probably, implement several Datasource-specific methods.
The general idea is to provide all the necessary information for the correct
open() of the DS. For our precious Fl_Directory_DS such methods are directory(),
pattern() and several others. User should define the directory() and pattern() 
prior to open() so Fl_Directory_DS would know what it has to open and read.</font></p>
 
<h2 class="western">4. Using a Datasource in widgets.</h2>
 
<p><font face="Clean">There are several ways to use a Datasource. Widgets
like Fl_ListView that represent multiple data rows may implement fill(Fl_Data_Source&amp;)
method. In the fill() method, widget usually opens the Datasource, reads
the data row-by-row, and closes the Datasource. The reading is the most important
part in that sequence. If all rows in the Datasource have same structure,
we can determine the way how to represent the data, from the first row. For 
the Fl_ListView it means - read the first row, get the number of columns
from the field_count() function, then iterate through the fields (columns,
in other words) and get all the information we need to display each column
properly. The following code shows the process: </font> </p>
 
<blockquote>
  <p><font face="Arial, sans-serif"><i>// First, open the Datasource</i></font></p>
  <p><font face="Arial, sans-serif"><i>if (!ds.open()) return;</i></font></p>
  <p><font face="Arial, sans-serif"><i>// Clear the existing rows</i></font></p>
  <p><font face="Arial, sans-serif"><i>clear();</i></font></p>
  <p><font face="Arial, sans-serif"><i>// Get the column number</i></font></p>
  <p><font face="Arial, sans-serif"><i>unsigned columnCount = ds.field_count();</i></font></p>
  <p><font face="Arial, sans-serif"><i>if (!columnCount) return;</i></font></p>
  <p><font face="Arial, sans-serif"><i>// For each column, get the data format
and create the column</i></font></p>
  <p><font face="Arial, sans-serif"><i>for (unsigned col = 0; col &lt; columnCount;
col++) {</i></font></p>
  <blockquote>
    <p><font face="Arial, sans-serif"><i>Fl_Data_Field&amp; df = ds.field(col);</i></font></p>
    <p><font face="Arial, sans-serif"><i>if (!df.visible) continue;</i></font></p>
    <p><font face="Arial, sans-serif"><i>int width = 100;</i></font></p>
    <p><font face="Arial, sans-serif"><i>if (df.width &gt;= 0) {</i></font></p>
    <blockquote>
      <p><font face="Arial, sans-serif"><i>width = df.width * text_size()
* 2 / 3;</i></font></p>
    </blockquote>
    <p><font face="Arial, sans-serif"><i>}</i></font></p>
    <p><font face="Arial, sans-serif"><i>add_column(df.name(),width);</i></font></p>
    <p><font face="Arial, sans-serif"><i>column_flags(col,df.flags);</i></font></p>
  </blockquote>
  <p><font face="Arial, sans-serif"><i>}</i></font></p>
</blockquote>
                  
<p style="font-style: normal;"><font face="Clean">Ok, now we have columns.
Lets fill them with data. After the Datasource is opened, the first row of
data (if any) is already available, and we can read it. Of course, the Datasource
may be empty and contain now rows. To make sure we are working with the valid
row, first check the result of ds.eof() function. If it returns false, we
can continue and read the data. For Fl_ListView, every item has the same
number of columns (for most practical cases). For every data row, Fl_ListView
reads every field and stores the information from that field in the ListView
item that represents the row. After the row is read we just go to the next
data row. The code below illustrates it.</font></p>
 
<blockquote>
  <p><font face="Arial, sans-serif"><i>// Read every row until eof()</i></font></p>
  <p><font face="Arial, sans-serif"><i>while (!ds.eof()) {</i></font></p>
  <blockquote>
    <p><font face="Arial, sans-serif"><i>// Create a new ListView item for
a data row</i></font></p>
    <p><font face="Arial, sans-serif"><i>Fl_ListView_ItemExt *item = new Fl_ListView_ItemExt();</i></font></p>
    <p><font face="Arial, sans-serif"><i>item-&gt;columns(columnCount);</i></font></p>
    <p><font face="Arial, sans-serif"><i>// Read every field of the data row
and put it in the ListView</i></font></p>
    <p><font face="Arial, sans-serif"><i>for (int col = 0; col &lt; (int)columnCount;
col++) {</i></font></p>
    <blockquote>
      <p><font face="Arial, sans-serif"><i>Fl_Data_Field&amp; df = ds.field(col);</i></font></p>
      <p><font face="Arial, sans-serif"><i>if (!df.visible) continue;</i></font></p>
      <p><font face="Arial, sans-serif"><i>item-&gt;flags(col, df.flags);</i></font></p>
      <p><font face="Arial, sans-serif"><i>if(df.type() == VAR_IMAGEPTR) item-&gt;image(col,
(Fl_Image *)df.as_image());</i></font></p>
      <p><font face="Arial, sans-serif"><i>else item-&gt;label(col, ds.field(col).as_string());</i></font></p>
    </blockquote>
    <p><font face="Arial, sans-serif"><i>}</i></font></p>
    <p><font face="Arial, sans-serif"><i>// After the row is read, go to the
next data row</i></font></p>
    <p><font face="Arial, sans-serif"><i>ds.next();</i></font></p>
  </blockquote>
  <p><font face="Arial, sans-serif"><i>}</i></font></p>
  <p><font face="Arial, sans-serif"><i>// Close the dataset</i></font></p>
  <p><font face="Arial, sans-serif"><i>ds.close();</i></font></p>
</blockquote>
                  <br>
</body>
</html>
